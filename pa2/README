README file for Programming Assignment 2 (Java edition)
=======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA2J/Makefile
 README
 cool.cup
 bad.cl
 good.cl
 cool-tree.java		  -> [course dir]/src/PA2J/cool-tree.java
 cool-tree.aps		  -> [course dir]/src/PA2J/cool-tree.aps
 AbstractSymbol.java	  -> [course dir]/src/PA2J/AbstractSymbol.java
 AbstractTable.java	  -> [course dir]/src/PA2J/AbstractTable.java
 BoolConst.java		  -> [course dir]/src/PA2J/BoolConst.java
 CgenClassTable.java	  -> [course dir]/src/PA2J/CgenClassTable.java
 CgenNode.java		  -> [course dir]/src/PA2J/CgenNode.java
 CgenSupport.java	  -> [course dir]/src/PA2J/CgenSupport.java
 ClassTable.java	  -> [course dir]/src/PA2J/ClassTable.java
 CoolParser.java	  -> [course dir]/src/PA2J/CoolParser.java
 CoolTokenLexer.java	  -> [course dir]/src/PA2J/CoolTokenLexer.java
 Flags.java		  -> [course dir]/src/PA2J/Flags.java
 IdSymbol.java		  -> [course dir]/src/PA2J/IdSymbol.java
 IdTable.java		  -> [course dir]/src/PA2J/IdTable.java
 IntSymbol.java		  -> [course dir]/src/PA2J/IntSymbol.java
 IntTable.java		  -> [course dir]/src/PA2J/IntTable.java
 ListNode.java		  -> [course dir]/src/PA2J/ListNode.java
 Parser.java		  -> [course dir]/src/PA2J/Parser.java
 StringSymbol.java	  -> [course dir]/src/PA2J/StringSymbol.java
 StringTable.java	  -> [course dir]/src/PA2J/StringTable.java
 SymbolTable.java	  -> [course dir]/src/PA2J/SymbolTable.java
 TokenConstants.java	  -> [course dir]/src/PA2J/TokenConstants.java
 TreeConstants.java	  -> [course dir]/src/PA2J/TreeConstants.java
 TreeNode.java		  -> [course dir]/src/PA2J/TreeNode.java
 Utilities.java		  -> [course dir]/src/PA2J/Utilities.java
 *.java			  other generated files

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.cup is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the CUP documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).  From
	this file, cool-tree.java is automatically generated by a
	utility that compiles the specification into Java classes for
	constructing tree nodes.  This file is provided for your
	reference.  DO NOT MODIFY.

        TreeNode.java and ListNode.java contain definitions used by the
        tree package. DO NOT MODIFY.  

        Parser.java contains a driver to test the parser. DO NOT MODIFY.

	Flags.java implements routines for parsing command line
	flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `CUP', or
        are internal parser support files.  DO NOT MODIFY.
        `CoolParser.java' is the generated Java file containing the
        parser.  DO NOT MODIFY this file directly; instead, edit
        cool.cup and this file will be regenerated automatically.

	Files not discussed are covered in the README for PA2J.

Instructions
------------

	To compile your parser program type:

	% make parser

	This compiles all the classes and produces an shell script named
	"parser" which invokes Parser.main() as the standalone phase of
	the Cool compiler.  It requires lexer, semant, and cgen to do
	anything useful.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% ./mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% make submit

	Running "submit" will collect the files cool.cup, good.cl, bad.cl,
	good.output, bad.output, and README. Don't forget to edit the
	README file to include your write-up, and to write your own test
	cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2J
-----------------

===================
>>>>> User ID <<<<<
===================
user: yh3483
user: borui

=======================================
>>>>> Non terminal Defined <<<<<
=======================================
nonterminal programc program;
nonterminal Classes class_list;
nonterminal class_c class;
nonterminal Features feature_list, let_list;
nonterminal Feature feature;
nonterminal Formals formal_list;
nonterminal formalc formal;
nonterminal Expressions expr_list_empty;
nonterminal Expressions expr_list_geq1;
nonterminal Expressions expr_list_comma;
nonterminal Expressions expr_list_darrow;
nonterminal Expressions expr_list_assign;
nonterminal Expression expr;
nonterminal typcase case;
nonterminal Cases casebr_list;
nonterminal branch casebr;
nonterminal let letbr;

=======================================
>>>>> Precedence Defined <<<<<
=======================================
precedence right ASSIGN; 
precedence left NOT;
precedence nonassoc LE, LT, EQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left ISVOID;
precedence left NEG;
precedence left AT;
precedence left DOT;

========================
>>>>> Design decisions <<<<<
========================

We used COOL's parsing action table in the COOL Manual to build the parser. 
Specifically, our non terminals include the LFSs in the parsing table. In case 
of multiple concatenations of object classes, we use lists of expressions, 
formals, features, and cases to handle the objects. For certain special cases 
of expression concatenations (comma delimited, darrow), we use expr_list_comma 
and expr_list_assign to handle these cases. Similarly, we use casebr_list to 
handle branching, and letbr to handle multiple LET expressions. For LET 
expression, we construct a let object as the return value for the previously 
concatenated let assignment to handle multiple variable assignments in LET.

For error handling, we detect errors and make sure the parser recovers from 
them and keeps running starting from the next valid block of code while parsing 
lists of classes, features, expressions, and the consecutive LET assignments. 
We used the standard way of using the "error" keyword to handle errors as 
suggested in JAVA CUP's manual. Finally, we use precedence declarations to 
handle ambiguity in parsing (see defined precedence above.)

========================
>>>>> Testing <<<<<
========================

We used a test driven development approach to make sure the robustness of our 
parser and its ability to recover from errors. We used test.cl from the previous 
assignment, and crafted our own good.cl and bad.cl for testing. We wrote a 
simple diff script to compare the result of our output and result of the 
reference parser's output. In good.cl, we wrote cases for each parsing actions 
for our parser to test its robustness. Similarly, in bad.cl we wrote cases for 
possible error conditions in lists of classes, features, expressions and let 
assignments for testing. There are some misalignment in terms of line number in 
the error output between our parser and the reference. We manually checked the 
correctness of the error output if that happens.

The test files are located at:
test/test.cl
test/good.cl
test/bad.cl
test/let_error.cl
test/prec_error.cl

The above test input files covers all the cases we can conceive of. Our 
implementation behaves the same (aside from the line numbers) as the reference 
under no parser error condition. With parser error, our implementation fails to 
catch as many errors as the reference in some corner cases with let and block 
construct. In the case when error spans over multiple line, our implementation
might produce the error message on a different token of the same error.
