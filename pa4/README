README file for Programming Assignment 4  (Java edition)
=======================================================

Your directory should now contain the following files:

 ASTConstants.java    -> [course dir]/src/PA4J/ASTConstants.java
 ASTLexer.java	      -> [course dir]/src/PA4J/ASTLexer.java
 ASTParser.java	      -> [course dir]/src/PA4J/ASTParser.java
 AbstractSymbol.java  -> [course dir]/src/PA4J/AbstractSymbol.java
 AbstractTable.java   -> [course dir]/src/PA4J/AbstractTable.java
 BoolConst.java
 Cgen.java	      -> [course dir]/src/PA4J/Cgen.java
 CgenClassTable.java
 CgenNode.java
 CgenSupport.java
 ClassTable.java      -> [course dir]/src/PA4J/ClassTable.java
 Flags.java	      -> [course dir]/src/PA4J/Flags.java
 IdSymbol.java	      -> [course dir]/src/PA4J/IdSymbol.java
 IdTable.java	      -> [course dir]/src/PA4J/IdTable.java
 IntSymbol.java
 IntTable.java	      -> [course dir]/src/PA4J/IntTable.java
 ListNode.java	      -> [course dir]/src/PA4J/ListNode.java
 Makefile	      -> [course dir]/assignments/PA4J/Makefile
 README
 StringSymbol.java
 StringTable.java     -> [course dir]/src/PA4J/StringTable.java
 SymbolTable.java     -> [course dir]/src/PA4J/SymbolTable.java
 SymtabExample.java   -> [course dir]/src/PA4J/SymtabExample.java
 TokenConstants.java  -> [course dir]/src/PA4J/TokenConstants.java
 TreeConstants.java
 TreeNode.java        -> [course dir]/src/PA4J/TreeNode.java
 Utilities.java	      -> [course dir]/src/PA4J/Utilities.java
 cool-tree.aps	      -> [course dir]/src/PA4J/cool-tree.aps
 cool-tree.java
 example.cl

	The Makefile contains targets for compiling and running your
	program, as well as handing it in. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to
	fill the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct,
	and why your test cases are adequate. It is part of the
	assignment to clearly and concisely explain things in text as
	well as to comment your code. Just edit this file.

	In example.cl you should write a correct Cool program which
	tests as many aspects of the code generator as possible. It
	should pass your code generator, and running spim on the
	generated output should run the program correctly.

	CgenClassTable.java CgenNode.java are the skeleton files for
	the code generator. These skeletons are much larger than the
	ones for previous assignments.  The skeletons provides three
	components of the code generator:

		- functions to build the inheritance graph; (we supply
		  this in case you didn't get this working for PA4)

		- functions to emit global data and constants;
		 
	You should work to understand this code, and it will help you
        write the rest of the code generator.

        TreeNode.java and ListNode.java contain definitions used by
        the tree package. DO NOT MODIFY.

        cool-tree.java specifies and give an implementation of Cool
        ASTs (see the README for PA3 and the "Cool Tour").  In this
        assignment, you will need to complete the code generating
        methods for all Cool expression nodes.

	BoolConst.java, IntSymbol.java, and StringSymbol.java are used
        to manage constants in Cool programs.  You will need to
        complete the method for generating constant definitions in
        each of these classes.

	CgenSupport.java is general support code for the code
	generator.  You can add functions and constants as you see
	fit, but do not modify anything that's already there.  This
	class also serves as a placeholder for a bunch of constants as
	well as functions to emit spim instructions (we supply these
	to save you some tedious coding).

	TreeConstants.java defined some useful symbol constants.  You
	may add some of your own, if you wish.

	ASTLexer.java, ASTParser.java, and ASTConstants.java implement
	a lexer and a parser for reading text representation of ASTs
	from console in the format produced by the parser phase. DO
	NOT MODIFY.

	Cgen.java supplies the driver for the compiler. You should not
        modify this code.  The script mycoolc can pass any of the
        standard flags to the code generator; for this assignment, -c
        (code generator debug) may be useful as it sets a global
        variable cgen_debug to true (1).  If you want your code
        generator to print debug information when the option is set,
        write your debug code in the following format:

	      if (cgen_debug)
	      {
		...
	      }

	SymbolTable.java contains a symbol table implementation. Read
	the comments in the file and look at the example in
	SymtabExample.java.  You are not required to use this code,
	but you may find it useful. DO NOT MODIFY.

Instructions
------------

	To compile your compiler and code generator type:

	% make cgen

	To test your compiler, type:

	% ./mycoolc <file1.cl>

	This command parses all the cool files given on the command
	line, passes them through the semantic checker, and then hands
	the program AST to your code generator.

	To run your compiler on the file example.cl, type:

	% make dotest

	To run the produced code:

	% spim -file file1.s  /* or the output filename you chose */
	
	To submit your work type:

	% make submit

	And run the "submit" program following the instructions on the
	course web page.
	
 	You may turn in the assignment as many times as you like.
 	However, only the last version will be retained for grading.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.  If at
	some point you get weird errors from the linker, you probably
	forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

***************************
*****     User ID     *****
***************************
user: yh3483
user: borui


**************************
*****     Design     *****
**************************

We break the sematic analysis into three phases, class check, feature check, 
and scope/type check. 

Phase 1: Class Check (ClassTable.java)
In this phase we construct an inheritance tree from all existing classes. As we 
build the tree, we check for the following errors:

	1.1. redefining basic or user-defined classes
	1.2. inheriting Int, Bool, String, or undefined classes
	1.3. cyclic inheritance
	1.4. absense of Main class

We stop the sematic analysis if there is any error in this phase. 



Phase 2: Feature Check (ClassTable.java)
In this phase we construct the object and method environments for each class. 
As we build the environments, we check for the following errors:

	2.1.1	declaring undefined class for attribute
	2.1.2	redefining attribute in superclass
	2.1.3	redefining attribute in the current class
	
	2.2.1	undefined class for parameter or return type	
	2.2.2	redefining method in the current class
	2.2.3	redefining method in superclass with different number of parameters
	2.2.3	redefining method in superclass with different parameter type or 
	return type
	2.2.4	duplicated parameter names
	2.2.5	absense of main method in Main class
	
Phase 3: Scope/Type Check (cool-tree.java)
In this phase perform scope and type check for each node in the AST. For each 
node, we recursively check the children nodes first and use the returned 
type information to check the current node. The type check rule is in accordance
to the COOL manual. 

For method, let statement, or case statement, we also enter/exit scope to allow
new variable or redefined variable. We use the updated scope to check for any 
undeclared identifier. 

If the type of a node cannot be determined because of type/scope error, we set 
the type to the type of the node to be Object.

***************************
*****     Testing     *****
***************************

We perform testing by comparing the results from our implementation to that 
from the reference solution. We construct various valid and invalid tests. 
These tests can be found under the tests directory. The bad.cl, bad2.cl contains
code with errors that can be recovered from the semantic analysis. good.cl,
easy.cl, and better.cl contains code that does not have any error. These files
are crafted to exhaustedly test the functionality of our code. The rest of
the test cases are related to checking class inheritance relationships.
Our implementation produces an equal amount of or more error messages than the 
reference in each test case.We have verified that the additional error messages 
we produce are in fact correct according to the COOL sematic rules.

